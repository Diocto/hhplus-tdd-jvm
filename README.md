# 개요
해당 보고서는 이번 과제에서 동시성을 어떻게 제어할 것인지 알아본 사항, 구현한 사항을 정리한 보고서입니다.
어떤 동시성 제어 방안을 알아봤는지, 어떻게 구현했는지, 어떤 결과를 얻었는지에 대해 정리하였습니다.

# 동시성 제어 방안들

## 1. synchronized 를 이용한 동시성 제어
synchronized 를 이용하여 함수를 구현하면 해당 함수는 한번에 하나의 스레드만 접근할 수 있게 된다. 이를 이용하여 동시성을 제어할 수 있다.
하지만 이번 과제에서 중요한 점은 단순히 하나의 기능의 동시성이 아닌, 두개 이상의 기능 (충전과 사용) 의 동시성을 제어해야 한다는 점이다. 각가의 함수를 synchronized 를 이용하여 동시성을 제어하면, 충전 메서드와 사용 메서드가 동시에 일어날 수 있기 때문에 이를 해결하기 위해서는 다른 방안이 필요하다.

## 2. ReentrantLock 을 이용한 동시성 제어
ReentrantLock 를 사용하면 별도로 lock 을 제어할 수가 있다. 인스턴스를 따로 생성한 다음 충전과 사용 함수에서 ReentrantLock 의 lock 을 걸어주면 충전과 사용 함수는 lock 을 획득할때까지 대기하기 때문에 동시성을 제어할 수 있다. 

## 3. lock key + ReentrantLock 을 이용한 동시성 제어 (구현)
2번 방법으로 구현하여도 좋지만, 우리가 관심있는건 각 유저의 포인트 충전/사용에 대한 동시성이다. 유저 A 와 유저 B 가 각각 충전/사용을 동시에 한다 하더라도, 서로에게는 영향이 없기 때문에 유저간의 동시성 제어는 성능을 저하시키게 된다.

그래서 처음에는 userId 를 key 로 하는 lock 을 생각해 봤으나, 유저가 늘어날때마다 lock key 가 늘어나는 방식은 현재로써는 과한 스펙이고, 또한 요청마다 늘어나는 Lock 을 저장하고 있는 것은 엄청난 리소스 낭비이다.

그래서 N 개의 Lock 을 유지하도록 하고, userId 를 N 으로 나눈 나머지를 key 로 하는 lock 을 사용하도록 하였다. 이렇게 하면 ThreadPool 처럼 N 개의 Lock 을 유지하면서, 같은 유저의 동시성도 제어할 수 있게 된다.

유저 수가 많아짐에 따라 N 값은 적절히 조정함으로써 성능을 최적화할 수 있다.

# 순차 처리는?
요구사항 중에 들어온 요청을 '순차적으로' 처리해야 한다는 조건이 있었는데, 이는 ReentrantLock 의 fair lock 을 사용하면 된다. fair lock 을 사용하면 먼저 lock 을 요청한 스레드가 먼저 lock 을 획득하게 되므로 순차 처리도 보장한다.
다만 fair lock 옵션을 사용하면 순차 처리를 위한 로직이 들어가기에 성능이 떨어지는 단점이 있다.
